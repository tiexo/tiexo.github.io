"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * CDN static file resolvers.
 *
 * @example
 *     <%- cdn(package, version, filename) %>
 *     <%- fontcdn(fontName) %>
 *     <%- iconcdn() %>
 */
var PROVIDERS = {
  LIBRARY: {
    cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }',
    loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }',
    jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }',
    unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }'
  },
  FONT: {
    google: 'https://fonts.googleapis.com/${ type }?family=${ fontname }',
    loli: 'https://fonts.loli.net/${ type }?family=${ fontname }'
  },
  ICON: {
    fontawesome: 'https://use.fontawesome.com/releases/v5.12.0/css/all.css'
  }
};
/**
 * Convert npm library path to CDN.js path
 */

var CDNJS_FIXTURES = {
  'moment': function moment(ver, fname) {
    return ['moment.js', ver, fname.startsWith('min/') ? fname.substr(4) : fname];
  },
  'outdatedbrowser': function outdatedbrowser(ver, fname) {
    return ['outdated-browser', ver, fname.startsWith('outdatedbrowser/') ? fname.substr(16) : fname];
  },
  'highlight.js': function highlightJs(ver, fname) {
    return ['highlight.js', ver, fname.endsWith('.css') && fname.indexOf('.min.') === -1 ? fname.substr(0, fname.length - 4) + '.min.css' : fname];
  },
  'mathjax': function mathjax(ver, fname) {
    return ['mathjax', ver, fname.startsWith('unpacked/') ? fname.substr(9) : fname];
  },
  'katex': function katex(ver, fname) {
    return ['KaTeX', ver, fname];
  },
  'pace-js': function paceJs(ver, fname) {
    return ['pace', ver, fname];
  },
  'clipboard': function clipboard(ver, fname) {
    return ['clipboard.js', ver, fname];
  },
  // disqusjs is not hosted on CDN.js
  'disqusjs': function disqusjs(ver, fname) {
    return [];
  }
};

module.exports = function (hexo) {
  hexo.extend.helper.register('cdn', function (_package, version, filename) {
    var _ref = _typeof(this.config.providers) === 'object' ? this.config.providers : {},
        _ref$cdn = _ref.cdn,
        cdn = _ref$cdn === void 0 ? 'jsdelivr' : _ref$cdn;

    if (cdn in PROVIDERS.LIBRARY) {
      cdn = PROVIDERS.LIBRARY[cdn];
    } // cdn.js does not follow a GitHub npm style like jsdeliver and unpkg do. Patch it!


    if (cdn === 'cdnjs' || cdn.startsWith('[cdnjs]')) {
      if (cdn.startsWith('[cdnjs]')) {
        cdn = cdn.substr(7);
      }

      if (filename.startsWith('dist/')) {
        filename = filename.substr(5);
      }

      if (Object.prototype.hasOwnProperty.call(CDNJS_FIXTURES, _package)) {
        var _CDNJS_FIXTURES$_pack = CDNJS_FIXTURES[_package](version, filename);

        var _CDNJS_FIXTURES$_pack2 = _slicedToArray(_CDNJS_FIXTURES$_pack, 3);

        _package = _CDNJS_FIXTURES$_pack2[0];
        version = _CDNJS_FIXTURES$_pack2[1];
        filename = _CDNJS_FIXTURES$_pack2[2];

        // package is not hosted on CDN.js
        if (!_package) {
          cdn = 'jsdelivr';
        }
      }
    }

    return cdn.replace(/\${\s*package\s*}/gi, _package).replace(/\${\s*version\s*}/gi, version).replace(/\${\s*filename\s*}/gi, filename);
  });
  hexo.extend.helper.register('fontcdn', function (fontName) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'css';

    var _ref2 = _typeof(this.config.providers) === 'object' ? this.config.providers : {},
        _ref2$fontcdn = _ref2.fontcdn,
        fontcdn = _ref2$fontcdn === void 0 ? 'google' : _ref2$fontcdn;

    if (fontcdn in PROVIDERS.FONT) {
      fontcdn = PROVIDERS.FONT[fontcdn];
    }

    return fontcdn.replace(/\${\s*fontname\s*}/gi, fontName).replace(/\${\s*type\s*}/gi, type);
  });
  hexo.extend.helper.register('iconcdn', function () {
    var _ref3 = _typeof(this.config.providers) === 'object' ? this.config.providers : {},
        _ref3$iconcdn = _ref3.iconcdn,
        iconcdn = _ref3$iconcdn === void 0 ? 'fontawesome' : _ref3$iconcdn;

    if (iconcdn in PROVIDERS.ICON) {
      iconcdn = PROVIDERS.ICON[iconcdn];
    }

    return iconcdn;
  });
};